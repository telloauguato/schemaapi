# Types

## Type _Global Schema_

`Global Schema` is the body of the standard schema used in SchemaAPI. It defines the general framework for dummy data generation, allowing you to configure essential properties to customize the generated data.

### Global Schema Structure

```json
{
  "name": "UserSchema",
  "description": "Schema for generating user data",
  "length": 10,
  "version": 1,
  "lang": "en",
  "seed": 12345,
  "content": { }
}
```

#### Global Schema Properties Table

| Name | Type | Description | Required |
| ------------- | -------- | ---------- | --------- |
| `name` | `string` | Schema name. | No |
| `description` | `string` | Schema description. | No |
| `length` | `number` | Number of objects to be generated. | No |
| `version` | `number` | SchemaAPI version. | Yes |
| `lang` | `string` | Data return language. | No |
| `seed` | `number` | Seed for generating pseudo-random data (for consistency). | No |
| `content` | `object` | Body of the schema containing the properties to be generated. | Yes |

#### Description of Properties

- **`name`**: Optional schema name, used to identify the generated dataset.
- **`description`**: An optional description of the schema, providing context or details about the use of the generated data.
- **`length`**: Defines the number of objects that will be generated by SchemaAPI. If not specified, a default value of `1` will be used. If it is a negative value, a random value will be generated between `1` and the absolute value of the number.
- **`version`**: Version of the SchemaAPI API to be used, used to determine the data generation mode applied to the content (`content`).
- **`seed`**: An optional seed to ensure consistency of data generated across different runs. Useful for repeatable testing.
- **`content`**: The core of the schema, where you define properties and their types. This is the most important part of the schema and must be configured according to the data you want to generate.

### Example

Here is a complete example using all `Global Schema` properties:

```json filename="User Schema"
{
  "name": "User Schema",
  "description": "Schema for generating user data",
  "length": 20,
  "version": 1,
  "seed": 98765,
  "lang": "en",
  "content": {
    "name": "name",
    "age": "number",
    "level": {
        "type": "options",
        "options": ["admin", "user", "anonymous"]
    }
  },
}
```

This example defines a schema to generate fictitious user data, including name, age and level, with a total of 20 generated objects, and a seed for data consistency.

## Populating `content`

The `content` field in SchemaAPI must be populated with key-value contents that match the data types supported by SchemaAPI. This field is essential for defining the structure and properties of the data that will be generated. Apply the [types](#all-types) below.

## Type Assignment

In SchemaAPI, types can be assigned in two ways: directly or embedded. This provides flexibility in defining schemas.

### Direct Attribution

You can assign a type directly to a property using the following syntax:

```json
{
 "key": "<type>"
}
```

import { Callout } from 'nextra/components'

<Callout type="warning" emoji="⚠️">
 In SchemaAPI, direct type assignment is limited to certain specific cases, such as `name`, `number`, `username`, `address` and `uuid`. For types that require additional configuration, such as specific data definitions or generation properties, it is recommended to use built-in assignment.
</Callout>

### Embedded Attribution

You can assign a type in more detail, specifying additional properties if necessary, using the following syntax:

```json
{
  "key": {
    "type": "<type>"
  }
}
```

### Examples

- **Direct Attribution**:

  ```json
  {
    "name": "name"
  }
  ```

- **Incorporated Attribution**:

  ```json
  {
    "name": {
      "type": "name",
      "suffix": "My name is "
    }
  }
  ```

Use the assignment method that best suits your needs, whether it's a simple setting or a more detailed configuration.

## All Types

Listed below are all data types supported by SchemaAPI for querying. Use this reference to configure its properties according to the specific needs of your project.

import { Cards, Card } from "nextra/components"
import { CaseSensitive, Hash, AtSign, User, Fingerprint, Map, Wand, Dices, TableProperties } from "lucide-react"

<Cards>
    <Card icon={<CaseSensitive />} title="Name" href="/types/name" />
    <Card icon={<Hash />} title="Number" href="/types/number" />
    <Card icon={<AtSign />} title="Email" href="/types/email" />
    <Card icon={<User />} title="Username" href="/types/username" />
    <Card icon={<Fingerprint />} title="UUID" href="/types/uuid" />
    <Card icon={<Map />} title="Address" href="/types/address" />
    <Card icon={<Wand />} title="Pattern" href="/types/pattern" />
    <Card icon={<Dices />} title="Options" href="/types/options" />
    <Card icon={<TableProperties />} title="Schema" href="/types/schema" />
</Cards>